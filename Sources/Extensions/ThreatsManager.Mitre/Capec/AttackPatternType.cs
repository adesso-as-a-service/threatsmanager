// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by Xsd2Code++. Version 5.2.97.0. www.xsd2code.com
//  </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable
namespace ThreatsManager.Mitre.Capec
{
using System;
using System.Diagnostics;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;
using System.Xml;
using System.IO;
using System.Text;
using System.Collections.Generic;

/// <summary>
/// An attack pattern is an abstraction mechanism for helping describe how an attack is executed. Each pattern defines a challenge that an attacker may face, provides a description of the common technique(s) used to meet the challenge, and presents recommended methods for mitigating an actual attack. Attack patterns help categorize attacks in a meaningful way in an effort to provide a coherent way of teaching designers and developers how their systems may be attacked and how they can effectively defend them.
/// </summary>
/// <summary>
/// The required Description element represents a high level description of the attack pattern. The description should be no longer than a few sentences and should include how malicious input is initially supplied, the weakness being exploited, and the resulting negative technical impact. A full step by step description does not belong as part of the description, but rather in the optional Execution_Flow element. The optional Typical_Severity element is used to capture an overall average severity value for attacks that leverage this attack pattern with the understanding that it will not be completely accurate for all attacks. The optional Likelihood_Of_Attack element is used to capture an average likelihood that an attack that leverages this attack pattern will succeed with the understanding that it will not be completely accurate for all attacks. A number of other optional elements are available, each of which is described in more detail within the corresponding complexType that it references.
/// </summary>
/// <summary>
/// The required ID attribute provides a unique identifier for the attack pattern. It is considered static for the lifetime of the entry. If this entry becomes deprecated, the identifier should not be reused and a placeholder for the deprecated attack pattern should be left in the catalog. The required Name attribute provides a descriptive title used to give the reader an idea of what the attack pattern represents. All words in the name should be capitalized except for articles and prepositions unless they begin or end the name. The required Abstraction attribute defines the abstraction level for this attack pattern. The required Status attribute defines the status level for this view. Please refer to the related simple types for a more detailed description of what information these attributes provide and a list of valid values and their meanings.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.8.4084.0")]
[Serializable]
[DebuggerStepThrough]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[XmlTypeAttribute(Namespace="http://capec.mitre.org/capec-3")]
public partial class AttackPatternType
{
    private static XmlSerializer _serializer;
    
        public StructuredTextType Description { get; set; }
        [XmlArrayItemAttribute("Alternate_Term", IsNullable=false)]
        public List<AlternateTermsTypeAlternate_Term> Alternate_Terms { get; set; }
        public LikelihoodEnumeration Likelihood_Of_Attack { get; set; }
        public SeverityEnumeration Typical_Severity { get; set; }
        [XmlArrayItemAttribute("Related_Attack_Pattern", IsNullable=false)]
        public List<RelatedAttackPatternTypeRelated_Attack_Pattern> Related_Attack_Patterns { get; set; }
        [XmlArrayItemAttribute("Attack_Step", IsNullable=false)]
        public List<ExecutionFlowTypeAttack_Step> Execution_Flow { get; set; }
        [XmlArrayItemAttribute("Prerequisite", IsNullable=false)]
        public List<StructuredTextType> Prerequisites { get; set; }
        [XmlArrayItemAttribute("Skill", IsNullable=false)]
        public List<SkillsTypeSkill> Skills_Required { get; set; }
        [XmlArrayItemAttribute("Resource", IsNullable=false)]
        public List<StructuredTextType> Resources_Required { get; set; }
        [XmlArrayItemAttribute("Indicator", IsNullable=false)]
        public List<StructuredTextType> Indicators { get; set; }
        [XmlArrayItemAttribute("Consequence", IsNullable=false)]
        public List<ConsequencesTypeConsequence> Consequences { get; set; }
        [XmlArrayItemAttribute("Mitigation", IsNullable=false)]
        public List<StructuredTextType> Mitigations { get; set; }
        [XmlArrayItemAttribute("Example", IsNullable=false)]
        public List<StructuredTextType> Example_Instances { get; set; }
        [XmlArrayItemAttribute("Related_Weakness", IsNullable=false)]
        public List<RelatedWeaknessesTypeRelated_Weakness> Related_Weaknesses { get; set; }
        [XmlArrayItemAttribute("Taxonomy_Mapping", IsNullable=false)]
        public List<TaxonomyMappingsTypeTaxonomy_Mapping> Taxonomy_Mappings { get; set; }
        [XmlArrayItemAttribute("Reference", IsNullable=false)]
        public List<ReferencesTypeReference> References { get; set; }
        [XmlArrayItemAttribute("Note", IsNullable=false)]
        public List<NotesTypeNote> Notes { get; set; }
        public ContentHistoryType Content_History { get; set; }
        [XmlAttribute(DataType="integer")]
        public string ID { get; set; }
        [XmlAttribute]
        public string Name { get; set; }
        [XmlAttribute]
        public AbstractionEnumeration Abstraction { get; set; }
        [XmlAttribute]
        public StatusEnumeration Status { get; set; }
    
    /// <summary>
    /// AttackPatternType class constructor
    /// </summary>
    public AttackPatternType()
    {
        Content_History = new ContentHistoryType();
        Notes = new List<NotesTypeNote>();
        References = new List<ReferencesTypeReference>();
        Taxonomy_Mappings = new List<TaxonomyMappingsTypeTaxonomy_Mapping>();
        Related_Weaknesses = new List<RelatedWeaknessesTypeRelated_Weakness>();
        Example_Instances = new List<StructuredTextType>();
        Mitigations = new List<StructuredTextType>();
        Consequences = new List<ConsequencesTypeConsequence>();
        Indicators = new List<StructuredTextType>();
        Resources_Required = new List<StructuredTextType>();
        Skills_Required = new List<SkillsTypeSkill>();
        Prerequisites = new List<StructuredTextType>();
        Execution_Flow = new List<ExecutionFlowTypeAttack_Step>();
        Related_Attack_Patterns = new List<RelatedAttackPatternTypeRelated_Attack_Pattern>();
        Alternate_Terms = new List<AlternateTermsTypeAlternate_Term>();
        Description = new StructuredTextType();
    }
    
    private static XmlSerializer SerializerXML
    {
        get
        {
            if ((_serializer == null))
            {
                _serializer = new XmlSerializerFactory().CreateSerializer(typeof(AttackPatternType));
            }
            return _serializer;
        }
    }
    
    #region Serialize/Deserialize
    /// <summary>
    /// Serialize AttackPatternType object
    /// </summary>
    /// <returns>XML value</returns>
    public virtual string Serialize()
    {
        StreamReader streamReader = null;
        MemoryStream memoryStream = null;
        try
        {
            memoryStream = new MemoryStream();
            System.Xml.XmlWriterSettings xmlWriterSettings = new System.Xml.XmlWriterSettings();
            System.Xml.XmlWriter xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings);
            SerializerXML.Serialize(xmlWriter, this);
            memoryStream.Seek(0, SeekOrigin.Begin);
            streamReader = new StreamReader(memoryStream);
            return streamReader.ReadToEnd();
        }
        finally
        {
            if ((streamReader != null))
            {
                streamReader.Dispose();
            }
            if ((memoryStream != null))
            {
                memoryStream.Dispose();
            }
        }
    }
    
    /// <summary>
    /// Deserializes AttackPatternType object
    /// </summary>
    /// <param name="input">string workflow markup to deserialize</param>
    /// <param name="obj">Output AttackPatternType object</param>
    /// <param name="exception">output Exception value if deserialize failed</param>
    /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
    public static bool Deserialize(string input, out AttackPatternType obj, out Exception exception)
    {
        exception = null;
        obj = default(AttackPatternType);
        try
        {
            obj = Deserialize(input);
            return true;
        }
        catch (Exception ex)
        {
            exception = ex;
            return false;
        }
    }
    
    public static bool Deserialize(string input, out AttackPatternType obj)
    {
        Exception exception = null;
        return Deserialize(input, out obj, out exception);
    }
    
    public static AttackPatternType Deserialize(string input)
    {
        StringReader stringReader = null;
        try
        {
            stringReader = new StringReader(input);
            return ((AttackPatternType)(SerializerXML.Deserialize(XmlReader.Create(stringReader))));
        }
        finally
        {
            if ((stringReader != null))
            {
                stringReader.Dispose();
            }
        }
    }
    
    public static AttackPatternType Deserialize(Stream s)
    {
        return ((AttackPatternType)(SerializerXML.Deserialize(s)));
    }
    #endregion
    
    /// <summary>
    /// Serializes current AttackPatternType object into file
    /// </summary>
    /// <param name="fileName">full path of outupt xml file</param>
    /// <param name="exception">output Exception value if failed</param>
    /// <returns>true if can serialize and save into file; otherwise, false</returns>
    public virtual bool SaveToFile(string fileName, out Exception exception)
    {
        exception = null;
        try
        {
            SaveToFile(fileName);
            return true;
        }
        catch (Exception e)
        {
            exception = e;
            return false;
        }
    }
    
    public virtual void SaveToFile(string fileName)
    {
        StreamWriter streamWriter = null;
        try
        {
            string dataString = Serialize();
            FileInfo outputFile = new FileInfo(fileName);
            streamWriter = outputFile.CreateText();
            streamWriter.WriteLine(dataString);
            streamWriter.Close();
        }
        finally
        {
            if ((streamWriter != null))
            {
                streamWriter.Dispose();
            }
        }
    }
    
    /// <summary>
    /// Deserializes xml markup from file into an AttackPatternType object
    /// </summary>
    /// <param name="fileName">string xml file to load and deserialize</param>
    /// <param name="obj">Output AttackPatternType object</param>
    /// <param name="exception">output Exception value if deserialize failed</param>
    /// <returns>true if this Serializer can deserialize the object; otherwise, false</returns>
    public static bool LoadFromFile(string fileName, out AttackPatternType obj, out Exception exception)
    {
        exception = null;
        obj = default(AttackPatternType);
        try
        {
            obj = LoadFromFile(fileName);
            return true;
        }
        catch (Exception ex)
        {
            exception = ex;
            return false;
        }
    }
    
    public static bool LoadFromFile(string fileName, out AttackPatternType obj)
    {
        Exception exception = null;
        return LoadFromFile(fileName, out obj, out exception);
    }
    
    public static AttackPatternType LoadFromFile(string fileName)
    {
        FileStream file = null;
        StreamReader sr = null;
        try
        {
            file = new FileStream(fileName, FileMode.Open, FileAccess.Read);
            sr = new StreamReader(file);
            string dataString = sr.ReadToEnd();
            sr.Close();
            file.Close();
            return Deserialize(dataString);
        }
        finally
        {
            if ((file != null))
            {
                file.Dispose();
            }
            if ((sr != null))
            {
                sr.Dispose();
            }
        }
    }
}
}
#pragma warning restore
